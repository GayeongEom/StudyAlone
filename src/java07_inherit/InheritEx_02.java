package java07_inherit;

//class Parent
//클래스이름 풀네임 : 패키지 이름.클래스명 -> InheritEx_01에서 이미 작성했었음 / 다른 소스파일이어도 같은 패키지 내에 같은 클래스 명으로 작성 불가
class Parent2{ 

	//private 접근제한자는 상속관계여도 접근할 수 없음
	//	private int num;

	//----------------------------------------------------

	public int num; //num1

	public void display() { //지워서 확인해보기
		System.out.println("부모 클래스");
	}
}


//-------------------------------------------------------------------------------------------------------------


class Child2 extends Parent2 {

//		public void method() {
//			
//			//에러, private 부모 멤버에 접근할 수 없음
//			num=123;
//		}
	//----------------------------------------------------
	public int num; //num2 / 상속받은 필드와 같은 이름 -> 적절하지 않은 변수 이름
	public String name; //자식의 고유한 멤버필드

	@Override
	public void display() {
		System.out.println("오버라이딩 메소드");

		int num; //num3 / 지역변수 선언
		
		num = 111; //num3 / 지역변수 num
		this.num = 222; //num2 / 멤버필드 num(자식클래스)
		super.num = 333; //num3 / 멤버필드 num(부모클래스)
		
	}

}


//-------------------------------------------------------------------------------------------------------------


public class InheritEx_02 {
	public static void main(String[] args) {

		Child2 c = new Child2();
		
		c.num = 12345; //num2 / 자식클래스의 num
		
		c.display(); //자식클래스의 오버라이딩 메소드

		System.out.println("-----------------------");
		//---------------------------------------
		
		Parent2 p = new Parent2();
		p.num = 45678; //num1
		p.display(); //부모클래스의 메소드
		
		System.out.println("-----------------------");
		//---------------------------------------
		
		Parent2 pc = new Child2(); //자식클래스를 부모타입으로 표현할 수 있음 / 부모클래스에 있는 멤버들만 접근할 수 있음
		
		//에러, ClassCaseException
//		Child2 cp = (Child2) Parent2(); //부모클래스를 자식타입으로 표현 불가 -> 자식은 부모에게 없는 멤버들도 갖고 있으므로 접근할 방법이 없음
		
		//---------------------------------------

		pc.num = 555; //num1 / pc변수의 데이터타입 Parent에 선언된 부모 멤버필드 num
		//변수는 타입을 보고 들어감
		
//		pc.name = "Alice"; //부모클래스타입이므로 자식 고유 멤버에 접근 불가
		
		//---------------------------------------

		//(Child2)pc. -> ((Child2)pc).//원래 인스턴스의 타입으로 강제 형변환 가능 -> Child2 pc = new Child2();
		//우선순위 1. 참조연산자 2. 형변환 연산자 이므로 형변환이 먼저 적용될 수 있도록 괄호로 감싸줘야함 1. 형변환 연산자 2. 참조연산자
		
		//형변환으로 Child2 클래스 타입으로 자식 멤버에 접근 가능해짐
		((Child2)pc).num = 678; //num2
		((Child2)pc).name = "Bob";
		
		//---------------------------------------

		//***************그림 확인하기*******************//
		pc.display(); //얘와 연결되는 건?
		//디버깅 F5(Step into)로 들어가면 "오버라이딩 메소드"로 연결됨
		//**바인딩 - 메소드의 호출코드와 구현코드가 연결되는 과정
		//	static 바인딩 : 프로그램 동작 전 객체 변수를 선언할 때 사용한 데이터타입의 구현코드로 바인딩
		//	dynamic 바인딩 : 프로그램 실행 중 메소드가 호출될 때 동적으로(new) 생성된 데이터타입의 구현코드로 바인딩
		//물리적인 연결은 "부모클래스"로 되지만 코드가 실행되면서 실질적 연결은 "오버라이딩 메소드"로 연결됨
		
		//정적바인딩은 직관적으로 부모로 가지만 / 동적바인딩은 안의 인덱스를 따라 자식의 메소드를 호출
		
		System.out.println(pc.num); //num1
		System.out.println(((Child2)pc).num); //num2

	}

}
